# PWN

[TOC]

## ELF

### ELF文件的类型

ELF即”可执行可链接格式“，Linux系统上所运行的就是ELF格式的文件，相关定义在`/usr/include/elf.h`文件里。

ELF文件分为三种类型，可执行文件(.exec)、可重定位文件(.rel)和共享目标文件(.dyn)：

- 可执行文件：经过链接的、可执行的目标文件，通常也被称为程序。
- 可重定位文件：由源文件编译而成且尚未链接的目标文件，通常以.o作为扩展名。用于与其他目标文件进行链接以构成可执行文件或动态链接库，通常是一段位置独立的代码。
- 共享目标文件：动态链接库文件。用于在链接过程中与其他动态链接库或可重定位文件一起构建新的目标文件，或者在可执行文件加载时，链接到进程中作为运行代码的一部分。

除此之外，核心转储文件（core dump file）作为进程意外终止时进程地址空间的转储，也是ELF文件的一种。使用gdb读取这类文件  可以辅助调试和查找程序崩溃的原因。

### ELF文件的结构

通常目标文件都会包含三个节：

- 代码（.text）：用于保存可执行的机器指令，通常设置为只读以防止被改写和利用
- 数据（.data）：用于保存已初始化的全局变量和局部静态变量
- BSS（.bss）：用于保存未初始化的全局变量和局部动态变量

ELF文件头位于目标文件最开始的位置，包含描述整个文件的一些基本信息，例如ELF文件类型、版本、目标机器、程序入口、段表和节表的位置和长度等。文件头部存在魔术字符（7f 45 4c 46），即字符串”\177ELF“，当文件被映射到内存时，可以通过搜索该字符确定映射地址，这在dump内存时非常有用。

节头表保存目标文件的节信息，表的每一项都是一个`Elf64_Shdr`结构体，记录了节的名字、长度、偏移、读写权限等信息。节头表的位置记录在文件头的`e_shoff`域中。节头表对于程序运行并不是必须的，所以常有程序去除节头表以增加反编译器的分析难度。

## 静态链接

静态链接在地址空间分配时使用相似节合并，将不同目标文件相同属性的节合并为一个节，如将`main.o`与`func.o`的`.text`节合并为新的`.text`节，将`main.o`与`func.o`的`.data`节合并为新的`.data`节，当前的链接器首先对各个节的长度、属性和偏移进行分析，然后将输入目标文件中符号表的符号定义与符号引用统一生成全局符号表，最后读取输入文件的各类信息对符号进行解析、重定位等操作。相似节的合并就发生在重定位时。完成后，程序中的每条指令和全局变量就都有唯一的运行时内存地址了。

可重定位文件中最重要的就是要包含重定位表，用于告诉链接器如何修改节的内容。每一个重定位表对应一个需要被重定位的节，例如名为`.rel.text`的节用于保存`.text`节的重定位表。`.rel.text`包含两个重定位入口，shared的类型`R_X86_64_32`用于绝对寻址，CPU将直接使用在指令中编码的32位值作为有效地址。func的类型`R_X86_64_PC32`用于相对寻址，CPU将指令中编码的32位值加上PC（下一条指令地址）的值得到有效地址。

## 动态链接

GCC默认使用动态链接编译，通过下面的命令我们将`func.c`编译为共享库，然后使用这个库编译`main.c`。参数`-shared`表示生成共享库，`-fpic`表示生成与位置无关的代码。这样可执行文件`func.ELF2`就会在加载时与`func.so`进行动态链接。需要注意的是，动态加载器`ld-Linux.so`本身就是一个共享库，因此加载器会加载并运行动态加载器，并由动态加载器来完成其他共享库以及符号的重定位。

```shell
gcc -shared -fpic -o func.so func.c
gcc -fno-stack-protector -o func.ELF2 main.c ./func.so
ldd func.ELF2
```

### 位置无关代码

可以加载而无须重定位的代码称为位置无关代码（PIC），它是共享库必须具有的属性，通过PIC，一个共享库的代码可以被无限多个进程所共享，从而节约内存资源。

由于一个程序的数据段和代码段的相对距离总是**保持不变**的，因此，指令和变量之间的距离是一个运行时常量，与绝对内存地址无关。于是就有了全局偏移量表（GOT），它位于数据段的开头用于保存全局变量和库函数的引用，每个条目占8个字节，在加载时会进行重定位并填入符号的绝对地址。

实际上，为了引入RELRO保护机制，GOT被拆分为`.got`节和`.got.plt`节两个部分，前者不需要延迟绑定，用于保存全局变量引用，加载到内存后被标记为只读；需要延迟绑定的后者则用于保存函数引用，具有读写权限。

### 延迟绑定

延迟绑定的基本思想是当函数第一次被调用时，动态链接器才进行符号查找、重定位等操作，如果未被调用则不进行绑定。

ELF文件通过过程链接表（PLT）和GOT的配合来实现延迟绑定，每个被调用的库函数都有一组对应的PLT和GOT。

位于代码段`.plt`节的PLT是一个数组，每个条目占16个字节。其中`PLT[0]`用于跳转到动态链接器，`PLT[1]`用于调用系统启动函数`_libc_start_main()`，我们熟悉的`main()`函数就是在这里面调用的，从`PLT[2]`开始就是被调用的各个函数条目。

位于数据段`.got.plt`节的GOT也是一个数组，每个条目占8个字节。其中`GOT[0]`和`GOT[1]`包含动态链接器在解析函数地址时所需要的两个地址（`.dynamic`和`relor`条目），`GOT[2]`是动态链接器`ld-Linux.so`的入口处，从`GOT[3]`开始就是被调用的各个函数条目，这些条目默认指向对应PLT条目的第二条指令，完成绑定后才会被修改为函数的实际地址。

## 汇编基础

### 指令集架构

在Linux发行版中，将x86-64称为amd64，而x86则称为i386。

#### 常用汇编指令

**MOV:**MOV指令的基本格式中，第一个参数为目的操作数，第二个参数为源操作数。如语句`MOV EAX, ECX`表示将ECX寄存器的值拷贝到EAX中。MOV指令支持从寄存器到寄存器、从内存到寄存器、从寄存器到内存、从立即数到内存和从立即数到寄存器的数据传送。

**INC、DEC:**分别用于操作数加1和减1，操作数可以是寄存器也可以是内存。

**ADD、SUB:**将长度相同的操作数进行相加和从目的操作数中减去源操作数。

**NEG:**对操作数执行求补运算。

**JMP:**无条件跳转指令，在编写汇编语言时需要使用一个标号来标识，汇编器在编译时就会将该标号转换成响应的偏移量。一般来说，该标号必须和JMP指令位于同一函数中，但使用全局标号则不受限制。

```assembly
	JMP labell
	MOV EBX, 0
labell:
	MOV EAX, 0
```

**LOOP:**用以创建一个循环代码块，ECX寄存器为循环的计数器，没经过一次循环，ECX的值将减去1。

```assembly
MOV AX, 0
MOV ECX, 3
L1:
INC AX
LOOP L1
XOR EAX, EBX
```
**PUSH、POP:**对ESP\RSP\SP寄存器的值进行减法运算，并使其减去4（32位）或8（64位），将操作数写入上述寄存器中指针指向的内存中。POP指令先从ESP\RSP\SP寄存器指向的内存中读取数据写入其他内存地址或寄存器，再将栈指针的数据增加4或8。

### 寄存器

| 操作数 |                        可用寄存器名称                        |
| :----: | :----------------------------------------------------------: |
|  8位   | AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L |
|  16位  | AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W |
|  32位  | EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D |
|  64位  | RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15 |

需要注意的是，在64位模式下，操作数的默认大小仍然为32位，且有8个通用寄存器；当给每条汇编指令增加REX（寄存器扩展）的前缀后，操作数变为64位，且增加了8个带有标号的通用寄存器（R8~R15）。

此外，64位处理器还有两个特点：第一，64位与32位有着相同的标志位状态；第二，64位模式下不能访问通用寄存器的高位字节（如AH、BH、CH及DH）。

### 数据类型

- 整数常量：对于整数常量，仅给出1234这类数字无法确定它的进制，因此需要使用后缀进行区分。此外，由于十六进制包含一些字母，为了避免汇编器解释成汇编指令或标识符，需要在以字母开头的十六机制数前加0表示，如0ABCDh（h表示十六进制）
- 浮点数常量：x86架构中有单独的浮点数寄存器和浮点数指令来处理相关浮点数常量。我们通常以十进制表示浮点数，而以十六进制编码浮点数。浮点数中至少包含一个整数和一个十进制的小数点。
- 字符串常量：字符串常量在内存中是以整数字节序列保存，下面是字符串'ABCDEFGH'在gdb中显示的样子，Intel处理器默认使用小端序表示字节序，TCP/IP协议的字节序使用大端。

```shell
gef x/s 0x4005d4
0x4005d4: 'ABCDEFGH'
gef x/gx 0x4005d4
0x4005d4: '0x4847464544434241'	// 小数端表示法
gef x/8x 0x4005d4
0x4005d4: 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 // 十六进制值对应字符的ASCII码
```

## Linux安全机制

### Linux调用约定

#### 内核接口

X86-32系统调用约定：Linux系统调用使用寄存器传递参数。eax为**syscall_number**，ebx、ecx、edx、esi和ebp用于将6个参数传递给系统调用。返回值保存在eax中。所有其他寄存器都保留在int 0x80中。

X86-64系统调用约定：内核接口使用的寄存器有rdi、rsi、rdx、r10、r8和r9。系统调用通过syscall指令完成。除了rcx、r11和rax，其他的寄存器都被保留（在系统调用时不要修改寄存器的值）。系统调用的编号必须在寄存器rax中传递。系统调用的参数限制为6个，不直接从堆栈上传递任何参数。返回时，rax中包含了系统调用的结果，而且只有integer或者memory类型的值才会被传递给内核。

### Stack Canaries



## Pwntools Usage

## ROP gadget

在栈缓冲区溢出的基础上，利用程序中已有的小片段(gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓gadgets 就是以ret 结尾的指令序列，通过这些指令序列，我们可以修改某些内存或者寄存器的值。
